
using reflection

struct bindable:
	value: object
	previous: object
	callbacks: objects

expression [a] bindable [(with|of) [value] %-object%] [(with|using) callback[s] %-objects%]:
	get:
		return a_bindable(expr-1, exprs-2, expr-1)

bindable struct property (old|previous) [bindable] value:
	return type: object
	get:
		return field previous of expr-1
	add:
		add change value to field previous of expr-1
	set:
		set field previous of expr-1 to change value 
	remove:
		remove change value from field previous of expr-1
	delete:
		delete field previous of expr-1

bindable struct property (current [bindable]|bindable) value:
	return type: object
	get:
		return bind_get(expr-1)
	add:
		bind_add(expr-1, change value)
	set:
		bind_set(expr-1, change value)
	remove:
		bind_remove(expr-1, change value)
	delete:
		bind_delete(expr-1)

effect bind %objects% to %bindable struct%:
	trigger:
		bind_bind(expr-2, exprs-1)

effect unbind %objects% from %bindable struct%:
	trigger:
		bind_unbind(expr-2, exprs-1)

function a_bindable(value: object = {_}, callbacks: objects = {_}, previous: object = {_}) -> bindable struct:
	return bindable struct instance:
		value: {_value}
		callbacks: {_callbacks::*}
		previous: {_previous}

function bind_get(bindable: bindable struct) -> object:
	return field value of {_bindable}

function bind_add(bindable: bindable struct, value: object) -> boolean:
	set {_current} to field value of {_bindable}
	set field previous of {_bindable} to {_current}
	add {_value} to {_current}
	set field value of {_bindable} to {_current}
	trigger_update({_bindable}, {_value})
	return true

function bind_set(bindable: bindable struct, value: object) -> boolean:
	set field previous of {_bindable} to field value of {_bindable}
	set field value of {_bindable} to {_value}
	trigger_update({_bindable}, {_value})
	return true

function bind_set_silently(bindable: bindable struct, value: object) -> boolean:
	set field value of {_bindable} to {_value}
	return true

function bind_remove(bindable: bindable struct, value: object) -> boolean:
	set {_current} to field value of {_bindable}
	set field previous of {_bindable} to {_current}
	remove {_value} from {_current}
	set field value of {_bindable} to {_current}
	trigger_update({_bindable}, {_value})
	return true

function bind_delete(bindable: bindable struct) -> boolean:
	set field previous of {_bindable} to field value of {_bindable}
	delete field value of {_bindable}
	trigger_update({_bindable}, {_value})
	return true

function bind_dispose(bindable: bindable struct) -> boolean:
	delete {_bindable}
	return true

function bind_bind(bindable: bindable struct, callbacks: objects) -> boolean:
	add {_callbacks::*} to field callbacks of {_bindable}
	return true

function bind_unbind(bindable: bindable struct, callbacks: objects) -> boolean:
	set {_bindable_callbacks::*} to field callbacks of {_bindable}
	for {_remove} in ({_callbacks::*} where [input is a function]):
		for {_callback} in ({_bindable_callbacks::*} where [equal(input, {_remove}) = true]):
			remove {_callback} from field callbacks of {_bindable}
	remove {_callbacks::*} from field callbacks of {_bindable}
	return true

function bind_update(bindable: bindable struct, value: object = {_}) -> boolean:
	set {_current} to {_value} ? field value of {_bindable}
	set {_previous} to field previous of {_bindable}
	for {_callback} in field callbacks of {_bindable}:
		if {_callback} is a function:
			run {_callback} with arguments {_current}, {_previous}
			continue

		run section {_callback} with arguments {_current}, {_previous}
	return true

local function equal(a: function, b: function) -> boolean:
	if all:
		name of {_a} = name of {_b}
		{_a}.source() = {_b}.source()
	then:
		return true
	return false
